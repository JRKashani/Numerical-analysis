function root = SolveBesselAI(Bi, m)
% SOLVEBESSELAI Finds the m-th positive root of x*J1(x) = Bi*J0(x).
%
% Inputs:
%   Bi : Biot number (0.1 <= Bi <= 60)
%   m  : Index of the root (1, 2, 3...)
%
% Strategy:
%   1. Scan for the bracket [x_min, x_max] containing the m-th root.
%   2. Initial Guess: Secant method approximation (smarter than midpoint).
%   3. Refine: Constrained Newton-Raphson (must stay in bracket).
%   4. Fallback: Robust Bisection if Newton fails or leaves bracket.

    % --- Configuration ---
    tol = 1e-8;      % Convergence tolerance
    max_iter = 100;  % Iteration limit
    
    % --- Step 1: Input Validation ---
    if Bi < 0.1 || Bi > 60
        error('Input Error: Bi must be between 0.1 and 60.');
    end
    if m <= 0 || mod(m, 1) ~= 0
        error('Input Error: m must be a positive integer.');
    end

    % --- Step 2: Define Function Handle ---
    target_func = @(x) bessel_func_product(x, Bi);

    % --- Step 3: Robust Scanning ---
    % Step size: pi/20 gives ~15-20 points per oscillation period (pi),
    % ensuring we don't skip roots even for high m.
    x_curr = 1e-4; 
    step_size = pi / 20; 
    roots_found = 0;
    
    % Limit: Roots are roughly at (m + 0.75)*pi. We add buffer.
    search_limit = (m + 1) * pi + 10; 
    
    x_min = NaN;
    x_max = NaN;
    bracket_found = false;

    while ~bracket_found
        x_next = x_curr + step_size;
        
        [f_currf_;
        [f_next, ~] = target_func(x_next);
        
        % Check for sign change
        if f_curr * f_next < 0
            roots_found = roots_found + 1;
            if roots_found == m
                x_min = x_curr;
                x_max = x_next;
                bracket_found = true;
            end
        end
        
        x_curr = x_next;
        
        if x_curr > search_limit
            error('Scan failed: Root #%d not found within x < %.1f', m, search_limit);
        end
    end

    % --- Step 4: Hybrid Solver ---
    try
        % Smart Initial Guess (Secant Approximation)
        % This places x0 closer to the root than a simple midpoint.
        [fa, ~] = target_func(x_min);
        [fb, ~] = target_func(x_max);
        
        % Safety: Ensure bracket is valid before starting
        if sign(fa) == sign(fb)
            error('Invalid bracket: endpoints have same sign');
        end
        
        % Linear interpolation for x0
        x0 = x_min - fa * (x_max - x_min) / (fb - fa);

        % Attempt Constrained Newton-Raphson
        [root, ~] = run_newton(target_func, x0, tol, max_iter, x_min, x_max);
        
    catch
        % Fallback to Bisection
        % (Triggered if Newton diverges, leaves bracket, or hits zero derivative)
        [root, ~] = run_bisection(target_func, x_min, x_max, tol, max_iter*10);
    end
end

% --- Helper: Constrained Newton-Raphson ---
function [x, iter] = run_newton(func, x, tol, max_iter, xmin, xmax)
    for iter = 1:max_iter
        [f, df] = func(x);
        
        % Success Check
        if abs(f) < tol, return; end
        
        % Stability Check: Relative derivative magnitude
        if abs(df) < 1e-12 * (1 + abs(f))
            error('Derivative too small relative to f(x)');
        end
        
        x_new = x - f/df;
        
        % Constraint Check: Must stay inside bracket
        if x_new < xmin || x_new > xmax
            error('Newton iterate left the valid bracket');
        end
        
        % Convergence Check
        if abs(x_new - x) < tol
            x = x_new;
            return;
        end
        x = x_new;
    end
    error('Newton did not converge within max_iter');
end

% --- Helper: Robust Bisection ---
function [root, iter] = run_bisection(func, a, b, tol, max_iter)
    [fa, ~] = func(a);
    [fb, ~] = func(b);
    
    % Final safety check before burning iterations
    if sign(fa) == sign(fb)
         error('Bisection failed: Bracket invalid (same signs)');
    end
    
    for iter = 1:max_iter
        c = (a + b) / 2;
        [fc, ~] = func(c);
        
        if abs(fc) < tol || (b - a)/2 < tol
            root = c;
            return;
        end
        
        if sign(fc) == sign(fa)
            a = c; fa = fc;
        else
            b = c; % fb = fc;
        end
    end
    root = (a + b) / 2;
end
% function validate_inputs(Biot_number, root_index_m)
% % Inputs:
% %   Biot_number:  Dimensionless number representing heat transfer ratio
% %   root_index_m: The index of the positive root to find (1, 2, 3...)
% 
%     % 1. Validate Biot Number Range
%     % Source constraint: 0.1 <= Bi <= 60 [cite: 252]
%     if Biot_number < 0.1 || Biot_number > 60
%         error(['Input Error: Biot number (Bi) must be between 0.1 ' ...
%             'and 60. You provided: %.4f'], Biot_number);
%     end
% 
%     % 2. Validate Root Index (m)
%     % Source constraint: m is a natural number [cite: 255]
%     % Check if m is positive and if it is an integer
%     if root_index_m <= 0 || mod(root_index_m, 1) ~= 0
%         error(['Input Error: The root index (m) must be a natural' ...
%             ' number (positive integer). You provided: %f'], root_index_m);
%     end
% end
% 
% %function [x_min, x_max] = scan_for_bracket(func_handle, target_m)
% % SCAN_FOR_BRACKET Scans for the m-th root interval.
% % Inputs:
% %   func_handle: The continuous function (x*J1 - Bi*J0)
% %   target_m:    The index of the root we want (1st, 2nd, etc.)
% % Output:
% %   [x_min, x_max]: The interval containing the m-th root.
% 
%     % Start slightly above 0 to avoid trivial solutions/singularities
%     x_current = 1e-4; 
%     step_size = 0.1;
% 
%     roots_found_count = 0;
%     bracket_found = false; % Flag to control the loop
% 
%     % Initialize outputs to avoid errors if loop fails
%     x_min = NaN;
%     x_max = NaN;
% 
%     while ~bracket_found
%         x_next = x_current + step_size;
% 
%         [f_curr, ~] = func_handle(x_current);
%         [f_next, ~] = func_handle(x_next);
% 
%         % Check for sign change
%         if sign(f_curr) ~= sign(f_next)
%             roots_found_count = roots_found_count + 1;
% 
%             % Check if this is the target m-th root
%             if roots_found_count == target_m
%                 x_min = x_current;
%                 x_max = x_next;
%                 bracket_found = true; % Set flag to exit loop
%             end
%         end
% 
%         % Move to next step
%         x_current = x_next;
%         search_limit = max(1000, target_m * 4);
% 
%         % Safety exit: Prevent infinite loops if inputs are bad
%         if x_current > search_limit
%             error('Exceeded search limit. Root m=%d not found.', target_m);
%         end
%     end
% end
